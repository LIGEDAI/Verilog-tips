

# Verilog里的一些常见概念
## tips1 按位与/或 和 逻辑与/或
在verilog 和 C 中：
- 按位与是 & ；逻辑与是 && 。
- 同样的，按位或是 | ；逻辑或是 || 。
## tips2 按位取反和逻辑非
在verilog 和 C 中：
- 按位取反是~
- 逻辑取反是！
e.g: `XGpioPs_WritePin`函数，如果按下列代码：
`int led_state = 0`
`XGpioPs_WritePin(&Gpio, MIOLED0, ~led_state);`
这样会导致错误，因为~是按位取反，而`XGpioPs_WritePin`函数输入的是一个32位无符号整数。所以如果这样写的话输入就变成了一个32位的全1，即0xFFFFFFFF
故正确的应该为`XGpioPs_WritePin(&Gpio, MIOLED0, !led_state);`
## tips3 二进制移位操作
在**无符号整数**或**使用算术右移的有符号整数**的情况下，二进制右移一位相当于除以 2
e.g.
10 (二进制 1010) >> 1 = 5 (二进制 0101)
9  (二进制 1001) >> 1 = 4 (二进制 0100)
-5 (二进制 11111011) >> 1 = -3 (二进制 11111101) // -5 / 2 = -2.5，向下取整到 -3
-4 (二进制 11111100) >> 1 = -2 (二进制 11111110) // -4 / 2 = -2，刚好是整数
注：**算术右移（Arithmetic Right Shift, ARS）**是一种**带符号位扩展的右移操作**，用于保持有符号整数的符号位（最高位）。其特点是：
-   **正数右移**：高位补 `0`，与无符号右移相同。
-   **负数右移**：高位补 `1`（即符号位的原值），保证负数仍然是负数。
-   **通常用于带符号整数（signed integer）**，以确保右移后仍然保持数值的正负性。
## tips4 组合逻辑电路描述
-   `always @(*)` 是一个 **组合逻辑块**，它 **不受时钟控制**，而是任何输入信号变化都会重新执行该块。
-   在组合逻辑描述 `next_state` 时，如果 `case` 语句的所有分支都没有覆盖 **所有可能情况**，综合工具可能会推导出 **锁存器**（Latch），导致电路行为不可预测。
